component tmc26x_bspi "Support for the TMC 26x series stepper motor driver using bspi interface";

description """The component takes parameters in the form of a comma-separated
list of bspi (buffered SPI) instance names, for example:

\\fB loadrt tmc26x_bspi bspi_chans=hm2_7i90.0.bspi.0, hm2_7i90.0.bspi.1\\fR

This driver initializes one or more TMC 26X drivers for step/dir use

It is assumed multiple drivers share the same chip select pin.

""";

pin out unsigned raw.#.in [6] "raw data";

variable unsigned *TMC26X_read[6];
variable unsigned *TMC26X_write[6];

variable unsigned state = 0;

option extra_setup yes;
option count_function yes;

license "GPL";
author "Joseph Calderon";

include "mesa-hostmot2/hostmot2.h";
;;

// to parse the modparam
char *bspi_chans[4] = {0,};
RTAPI_MP_ARRAY_STRING(bspi_chans, 4, "BSPI Channel names");

#include "rtapi_math.h"

static int write(void *subdata) {
  struct __comp_state *__comp_inst = subdata;
  unsigned int i = 0;

  if (state == 5) return 0;

  // address, sgfilt off, threshold value, current scaling (5-bit value appended)
  uint32_t sgthresh_mask = 0b00000111111100000000;
  int32_t sgthres_val = 60;
  uint32_t cscale_mask = 0b00000000000000011111;
  uint32_t cscale_val = 12;
  uint32_t sgcsconf = 0b11010000000000000000 | ((sgthres_val << 8) & sgthresh_mask) | (cscale_val & cscale_mask);

  uint32_t drvconf  = 0b11100000000000000000; // enable step/dir mode, read back microstep position
  uint32_t smarten  = 0b10100000000000000000; // disable coolstep
  uint32_t chopconf = 0b10011000001000010011; // chopconf defaults
  uint32_t drvctrl  = 0b00000000000000000100; // 16x microstepping

  switch(state) {
    case 0:
        *TMC26X_write[0] = sgcsconf;
      state++;
      break;
    case 1:
        *TMC26X_write[0] = chopconf;
      state++;
      break;
    case 2:
        *TMC26X_write[0] = drvconf;
      state++;
      break;
    case 3:
        *TMC26X_write[0] = drvctrl;
      state++;
      break;
    case 4:
        *TMC26X_write[0] = smarten;
      state=5;
      break;
  }

  return 0;
}

EXTRA_SETUP(){
  int i, r;
  char *name = bspi_chans[extra_arg]; // This is the string which identifies board and instance

  // Set up channel descriptors
  //hm2_bspi_setup_chan(name, chan, cs, bits, mhz, delay(ns), cpol, cpha, /clear, /echo, samplelate)
  r  = hm2_bspi_setup_chan(name, 0, 0, 20, 200/1000.0f, 0, 0, 0, 0, 0, 0);

  if (r < 0) {
    HM2_ERR_NO_LL("There have been %i errors during channel setup, quitting\n", -r);
    return -EINVAL;
  }

  // Add BSPI Frames
  r += hm2_tram_add_bspi_frame(name, 0, &TMC26X_write[0], NULL);

  // This is required, or nothing happens.
  r += hm2_allocate_bspi_tram(name);

  // Tell the bspi driver which function to call
  r += hm2_bspi_set_write_function(name, &write, __comp_inst);

  if (r < 0) {
    HM2_ERR_NO_LL("There have been %i errors during TRAM allocation setup, quitting\n", -r);
    return -EINVAL;
  }
  return 0;
}

int get_count(void){
  int i;
  for (i= 0; bspi_chans[i] != NULL && i < 4; i++){}
  return i;
}
