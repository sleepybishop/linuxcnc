component tmc26x_bspi "Support for the TMC 26x series stepper motor driver using bspi interface";

description """The component takes parameters in the form of a comma-separated
list of bspi (buffered SPI) instance names, for example:

\\fB loadrt tmc26x_bspi bspi_chans=hm2_7i90.0.bspi.0, hm2_7i90.0.bspi.1\\fR

""";

pin out unsigned raw.#.in      [6] "raw data";
pin out signed stallguard.#.in [6] "stallguard value";
pin out signed coolstep.#.in   [6] "coolstep value";
pin out bit stalled.#.in       [6] "motor stalled";
pin out bit overtemp.#.in      [6] "motor temp warning";
pin out bit shorted.#.in       [6] "motor shorted to ground";
pin out bit openload.#.in      [6] "open load on motor";
pin out bit standstill.#.in    [6] "motor standstill";

//pin in signed microsteps.#.out [6] "motor microsteps";
//pin in signed maxcurrent.#.out [6] "motor max current";

variable unsigned *TMC26X_read[6];
variable unsigned *TMC26X_write[6];

variable unsigned state = 0;

option extra_setup yes;
option count_function yes;

license "GPL";
author "Joseph Calderon";

include "mesa-hostmot2/hostmot2.h";
;;

// to parse the modparam
char *bspi_chans[4] = {0,};
RTAPI_MP_ARRAY_STRING(bspi_chans, 4, "BSPI Channel names");

#include "rtapi_math.h"

static uint32_t calcCurrent(double mASetting, double resistor_value, int vsense) {
  unsigned char current_scaling = 0;
  double vsense_value = vsense ? 0.165 : 0.305;

  //calculate the current scaling from the max current setting (in mA)
  current_scaling = (unsigned char)((resistor_value*mASetting*32.0/(vsense_value*1000.0*1000.0))-0.5); //theoretically - 1.0 for better rounding it is 0.5

  if (current_scaling > 31) {
    current_scaling = 31;
  }

	return current_scaling;
}
        
static int read(void *subdata, rtapi_u32 *data, int rdcount) {
  struct __comp_state *__comp_inst = subdata;
  unsigned int i = 0;

  for (i = 0; i < 6; i++) {
    stalled_in(i)         = ((data[i] >>  0) & 0x1) ? 1 : 0;
    overtemp_in(i)        = ((data[i] >>  1) & 0x1) ? 1 : 0;
    overtemp_in(i)       |= ((data[i] >>  2) & 0x1) ? 1 : 0;
    shorted_in(i)         = ((data[i] >>  3) & 0x3) ? 1 : 0;
    openload_in(i)        = ((data[i] >>  5) & 0x3) ? 1 : 0;
    standstill_in(i)      = ((data[i] >>  7) & 0x1) ? 1 : 0;
    stallguard_in(i)      = ((data[i] >> 10) ) & 0b01111100000;
    coolstep_in(i)        = ((data[i] >> 10) ) & 0b00000011111;

    raw_in(i) = data[i];
  }
  return 0;
}


static int write(void *subdata) {
  struct __comp_state *__comp_inst = subdata;
  int num_motors = 6;

  if (state == 5) return 0;

  int vsense = 0;
  int cscale_val = calcCurrent(1650, 51, vsense);
  if (cscale_val < 16) {
  vsense = 1;
  cscale_val = calcCurrent(1650, 51, vsense);
  }

  int sgthres_val = 10; // -64 to 63, sensitivity low to high
  uint32_t sgthresh_mask = 0b00000111111100000000;
  uint32_t cscale_mask   = 0b00000000000000011111;

  uint32_t sgcsconf = 0b11000000000000000000 | ((sgthres_val << 8) & sgthresh_mask) | (cscale_val & cscale_mask);
  uint32_t drvconf  = 0b11100000000000100000; // enable step/dir mode, read back SG data
  uint32_t smarten  = 0b10101000001101100001; // SEIMIN 1/4 CS, SEDN 8, SEMAX 16, SEUP 8, SEMIN 32
  uint32_t chopconf = 0b10011000001000010011; // chopconf defaults
  uint32_t drvctrl  = 0b00000000000100000010; // 64x microstepping (INTPOL off, DEDGE on)

  drvconf |= (vsense & 0x1) << 6;

  switch(state) {
    case 0:
    for (int i = 0; i < num_motors; i++) {
      *TMC26X_write[i] = sgcsconf;
    }
    state++;
    break;
    case 1:
    for (int i = 0; i < num_motors; i++) {
      *TMC26X_write[i] = chopconf;
    }
    state++;
    break;
    case 2:
    for (int i = 0; i < num_motors; i++) {
      *TMC26X_write[i] = drvconf;
    }
    state++;
    break;
    case 3:
    for (int i = 0; i < num_motors; i++) {
      *TMC26X_write[i] = drvctrl;
    }
    state++;
    break;
    case 4:
    for (int i=0; i < num_motors; i++) {
      *TMC26X_write[i] = smarten;
    }
    state=4;
    break;
  }

  return 0;
}

EXTRA_SETUP(){
  int i, r;
  char *name = bspi_chans[extra_arg]; // This is the string which identifies board and instance

  // Set up channel descriptors
  //hm2_bspi_setup_chan(name, chan, cs, bits, mhz, delay(ns), cpol, cpha, /clear, /echo, samplelate)
  r  = hm2_bspi_setup_chan(name, 0, 0, 20, 10/1000.0f, 0, 0, 0, 0, 0, 0);
  r += hm2_bspi_setup_chan(name, 1, 1, 20, 10/1000.0f, 0, 0, 0, 0, 0, 0);
  r += hm2_bspi_setup_chan(name, 2, 2, 20, 10/1000.0f, 0, 0, 0, 0, 0, 0);
  r += hm2_bspi_setup_chan(name, 3, 3, 20, 10/1000.0f, 0, 0, 0, 0, 0, 0);
  r += hm2_bspi_setup_chan(name, 4, 4, 20, 10/1000.0f, 0, 0, 0, 0, 0, 0);
  r += hm2_bspi_setup_chan(name, 5, 5, 20, 10/1000.0f, 0, 0, 0, 0, 0, 0);

  if (r < 0) {
    HM2_ERR_NO_LL("There have been %i errors during channel setup, quitting\n", -r);
    return -EINVAL;
  }

  // Add BSPI Frames
  r += hm2_tram_add_bspi_frame(name, 0, &TMC26X_write[0], NULL);
  r += hm2_tram_add_bspi_frame(name, 1, &TMC26X_write[1], NULL);
  r += hm2_tram_add_bspi_frame(name, 2, &TMC26X_write[2], NULL);
  r += hm2_tram_add_bspi_frame(name, 3, &TMC26X_write[3], NULL);
  r += hm2_tram_add_bspi_frame(name, 4, &TMC26X_write[4], NULL);
  r += hm2_tram_add_bspi_frame(name, 5, &TMC26X_write[5], NULL);

  // This is required, or nothing happens.
  r += hm2_allocate_bspi_tram(name);

  // Tell the bspi driver which function to call
  r += hm2_bspi_set_write_function(name, &write, __comp_inst);

  // Tell the bspi driver which function to call
  r += hm2_bspi_set_read_function(name, &read, __comp_inst);

  if (r < 0) {
    HM2_ERR_NO_LL("There have been %i errors during TRAM allocation setup, quitting\n", -r);
    return -EINVAL;
  }
  return 0;
}

int get_count(void){
  int i;
  for (i= 0; bspi_chans[i] != NULL && i < 4; i++){}
  return i;
}
